; $Id: vileinit.rc,v 1.42 2013/09/27 08:21:10 tom Exp $
; This is a sample which may be installed as .vilerc (or vile.rc for non-Unix
; systems), or source'd as-is to provide quick initialization of some useful
; macros and settings.

; General preferences:
set autoindent
set check-modtime
set cmode
set flash
set implybuffer
set nomultibeep
set nowarn-reread
set ruler
set showmatch
set smooth
set undolimit=100
set ignoresuffix '\.\(in\|orig\|~\)$'

; Since 'map' overrides 'bind-key', ensure that we don't have a mapping for
; function-key 1, since it is useful for HELP.
map #1 xx
unmap #1
bind-key help #1

; A tab is useful for stepping through the windows:
bind-key next-window ^I

; In command-mode, we can use home/end keys most effectively by going to either
; end of the line:
bind-cmdmode-key goto-bol FN-H
bind-cmdmode-key goto-eol FN-E

; Special settings that depend on the platform/configuration.  Note
; that there is no special symbol denoting "UNIX", so we infer it from
; the $pathlist-separator variable.

~if &not &sin $cfgopts "noshell"
~if &seq $pathlist-separator ":"
	; Though you probably prefer an interactive shell that
	; supports history, command-line editing, etc., there are good
	; reasons for using Bourne shell to run subprocesses from vile
	; (speed, and usually lack of interference from stty commands
	; with the syntax filters).
	setv $shell=/bin/sh

	~if &seq $os "cygwin"
		set noresolve-links
	~else
		set resolve-links
	~endif
	set glob=on
~endif

~if &seq $progname xvile
	setv $xshell="xterm -e xshell.sh"
	setv $xshell-flags=""
~endif

~endif

~if &sin $progname winvile
	bind-key backward-row Shift+#A
	bind-key forward-row  Shift+#B
	bind-key right-arrow  Shift+#C
	bind-key left-arrow   Shift+#D
	; ...and of course back-tab:
	bind-key previous-window	Shift+^I
~elseif &or &sin $cfgopts "terminfo" \
	&or &sin $cfgopts "termcap" \
	    &sin $cfgopts "curses"

	set xterm-mouse
	set xterm-fkeys

	; If your keyboard is setup to transmit META as an escape character,
	; these mappings are useful for undo/redo/kill
	map u u
	map r r
	map k k

	; Shifted arrow-keys from XFree86 xterm, mapped to next-row and
	; previous-row.  They are available when the sunKeyboard resource
	; is false, i.e., the "VT220 Keyboard" menu option is not checked.
	~if &sin &env 'TERM' 'xterm'
		; These are the newer flavor:
		;map [1;2A 
		;map [1;2B 
		;map [1;2C #C
		;map [1;2D #D
	~elseif &or \
		&sin &env 'TERM' 'konsole' \
		&sin &env 'TERM' 'gnome'
		; GNOME or KDE (unclear because the developers do not give
		; credit except in the vaguest possible terms) copied the
		; bindings for xterm-94, and then one copied from the other.
		; However, this is the old, deprecated flavor, before xterm
		; patch #167 (see modifyCursorKeys in the xterm manpage):
		map [2A 
		map O2A 
		map [2B 
		map O2B 
		map [2C #C
		map O2C #C
		map [2D #D
		map O2D #D
	~elseif &sin &env 'TERM' 'rxvt'
		map [a 
		map [b 
		map [c #C
		map [d #D
	~endif
	; You may have a back-tab (map it to previous-window).  This is fairly
	; standard since it is adapted from the control sequence with the same
	; name.
	map [Z O
	;
	; If "xterm-fkeys" is enabled, it alters the input decoding so that
	; function keys can have shift/control/alt modifiers.  That means it
	; may override the map commands for the shifted cursor keys:
	bind-key previous-row Shift+#A
	bind-key next-row     Shift+#B
	bind-key right-arrow  Shift+#C
	bind-key left-arrow   Shift+#D
	; ...and the alt-keys:
	bind-key undo-changes-backward	M-u
	bind-key redo-changes-forward	M-r
	bind-key kill-buffer		M-k
	; ...and of course back-tab:
	bind-key previous-window	#b
~endif

; Useful macros for function keys:

store-procedure ToggleTabs "Toggle tabs 4/8"
~if &sin $bflags s
	write-message "Cannot set tabs"
~else
	~if &equ $ts 4
		setl ts=8
		setl sw=8
	~else
		setl ts=4
		setl sw=4
	~endif
	write-message &cat "Set tabs to " $ts
~endif
~endm
map #3 :ToggleTabs

store-procedure ToggleList "Toggle list/nolist mode"
~if $list
	setl nolist
~else
	setl list
~endif
write-message &cat "Set list to " $list
~endm
map #4 :ToggleList

map #5 :entab-lines-til
map #6 :detab-lines-til
map #7 :format-til

; generalized from ToggleList, for any boolean mode
store-procedure ToggleMode mode='Mode'
	~local %value
	setv %value &local $1
	~if &seq "TRUE" %value
		eval &cat "setl no" $1
	~elseif &seq "FALSE" %value
		eval &cat "setl " $1
	~else
		write-message "Not a boolean mode"
	~endif
~endm
map #4 :ToggleMode list

; take the identifier under the cursor, wrap it in '<', '>' and search for it.
store-procedure next-cur-identifier "Find next occurrence of current $identifier"
	~force search-forward &cat '\<' &cat $identifier '\>'
~endm
bind-key next-cur-identifier ^X-,

; Take the identifier under the cursor, wrap it in '<', '>' and search for it.
; in the alternate buffer.
store-procedure next-alt-identifier "Find current $identifier in alternate buffer"
	~local %osearch
	set-variable %osearch $identifier
	alternate-buffer
	~force search-forward &cat '\<' &cat %osearch '\>'
	position-window "+"
	alternate-buffer
~endm
bind-key next-alt-identifier ^A-,

;; Macro to center a line.
store-procedure center "Center the current line"
	first-nonwhite
	delete-til beginning-of-line
	trim-lines-til end-of-line
	set-variable %insert &DIV &SUB 80 $llength 2
	~if &GRE %insert 0
		%insert insert-string " "
	~endif
~endm
bind-key center ^X-C

~if &sin $cfgopts "perl"
store-procedure hyper-next "Execute embedded hypertext command and move cursor past it"
    ~force execute-hypertext-command
    ~if &not $status
	~force forward-character-to-eol
    ~endif
~endm
bind-key hyper-next ^X-^M
~endif

; Make the current buffer writable and then write it out.
~if &or &seq $os "dos" &seq $os "win32"
	use-register w load-register ":!attrib -r %:w"
~elseif &seq $os "vms"
	use-register w load-register ":!set protection=(o:rwed) %:w"
~else
	use-register w load-register ":!chmod +w %:w"
~endif

; Variants on grep of the current token.  You need GNU grep for the -w (word)
; option.  VMS has a native search utility.
~if &seq $pathlist-separator ":"
	use-register f load-register "!grep -n -w : *.in *.m4 *.[chly] *.def *.cc *.cpp *.xs"
	use-register g load-register "!egrep -n : *.[chly] *.def *.cc *.cpp *.xs"
	use-register h load-register "!egrep -n : *.* */*"
	use-register i load-register "!egrep -n : /usr/include/*.h /usr/include/*/*.h /usr/local/include/*.h"
	use-register j load-register "!egrep -n : *.[ch] */*.[ch]"
~elseif &or &seq $os "dos" &seq $os "win32"
	use-register f load-register "!grep -n -w & *.in *.m4 *.c *.h *.def *.cc *.cpp *.cs *.xs"
	use-register g load-register "!egrep -n & *.c *.h *.def *.cc *.cpp *.cs *.xs"
~elseif &seq $os "vms"
	use-register f load-register "!search/exact *.c,*.h,*.com,*.mms &"
	use-register g load-register "!search *.c,*.h,*.com,*.mms &"
	use-register j load-register "!search [...]*.c,*.h,*.com,*.mms &"
~endif

unsetv %filters-modes
source vileperl.rc
source modes.rc
source palettes.rc
source filters.rc
source which.rc

~if &not &seq $os "vms"
	source manpage.rc
~endif

~if &or \
	&seq $pathlist-separator ":" \
	&seq $os "win32"
	source spell.rc
~endif
